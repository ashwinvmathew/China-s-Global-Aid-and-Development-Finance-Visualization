<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        .btn-group { display: none !important; }
        body { font-family: sans-serif; margin: 0; display: flex; justify-content: center; align-items: center; height: 100vh; overflow: hidden; }
        .card { width: 100%; height: 100%; padding: 10px; box-sizing: border-box; display: flex; flex-direction: column; align-items: center; }
        #chart { flex: 1; width: 100%; }
        
        .bar { cursor: pointer; }
        .bar:hover { filter: brightness(0.85); }
        /* Made font slightly smaller to fit text better */
        .axis text { font-size: 11px; fill: #555; }
        .grid line { stroke: #eee; stroke-dasharray: 3,3; }
        .context-bg { fill: #f9f9f9; }
        .brush .selection { fill: #333; fill-opacity: 0.1; stroke: #333; }
        
        .zoom-group { margin-top: 10px; display: flex; gap: 10px; }
        .zoom-group button { padding: 5px 10px; background: white; border: 1px solid #ccc; cursor: pointer; border-radius: 4px; }
        .zoom-group button:hover { background: #eee; }
        
        #tooltip { position: absolute; opacity: 0; background: white; padding: 8px; border: 1px solid #ccc; border-radius: 4px; pointer-events: none; font-size: 12px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); }
        .loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 16px; color: #666; }
    </style>
</head>
<body>

<div class="card">
    <div id="chart"><div class="loading">Loading Data...</div></div>
    <div class="zoom-group">
        <button onclick="zoomIn()">+</button>
        <button onclick="zoomOut()">-</button>
        <button onclick="resetZoom()">Reset</button>
    </div>
</div>
<div id="tooltip"></div>

<script>
    const margin = { top: 20, right: 30, bottom: 40, left: 200 }; // Left margin controls space for text
    const width = 600 - margin.left - margin.right;
    const height = 400 - margin.top - margin.bottom;
    const brushHeight = 30;

    const flowColors = { "oda": "#d62728", "oof": "#ff7f0e" };
    let currentFlow = "oda";
    let preCalcData = { "oda": [], "oof": [] };
    let brush, brushGroup, x, y, x2, xAxisGroup, yAxisGroup, gridGroup;

    const svg = d3.select("#chart").append("svg")
        .attr("viewBox", `0 0 600 ${400 + brushHeight + 40}`)
        .attr("preserveAspectRatio", "xMidYMid meet")
        .style("width", "100%").style("height", "100%")
        .style("opacity", 0);

    const focus = svg.append("g").attr("transform", `translate(${margin.left},${margin.top})`);
    const context = svg.append("g").attr("transform", `translate(${margin.left},${height + margin.top + 40})`);

    focus.append("defs").append("clipPath").attr("id", "clip").append("rect").attr("width", width).attr("height", height);
    
    x = d3.scaleLinear().range([0, width]);
    y = d3.scaleBand().range([0, height]).padding(0.3);
    x2 = d3.scaleLinear().range([0, width]);

    gridGroup = focus.append("g").attr("class", "grid");
    xAxisGroup = focus.append("g").attr("class", "axis x-axis").attr("transform", `translate(0,${height})`);
    yAxisGroup = focus.append("g").attr("class", "axis y-axis");
    const barGroup = focus.append("g").attr("clip-path", "url(#clip)");

    d3.dsv(";", "data/data.csv").then(data => {
        function calculateStats(type) {
            const filtered = data.filter(d => (d["Flow Class"]||"").toLowerCase().includes(type));
            const rolled = d3.rollup(filtered, v => d3.sum(v, d => {
                let s = d[" Adjusted Amount (Constant USD 2021) "] || d["Adjusted Amount (Constant USD 2021)"];
                return s ? parseFloat(String(s).replace(/\./g, "").replace(",", ".")) : 0;
            }), d => d["Sector Name"]);
            
            return Array.from(rolled, ([sector, value]) => ({ sector, value }))
                .filter(d => d.value > 0 && d.sector)
                .sort((a, b) => b.value - a.value)
                .slice(0, 15); // <--- KEEP ONLY TOP 15 (Removes low sectors)
        }

        preCalcData["oda"] = calculateStats("oda");
        preCalcData["oof"] = calculateStats("oof");

        d3.select(".loading").remove();
        svg.style("opacity", 1);

        context.append("rect").attr("class", "context-bg").attr("width", width).attr("height", brushHeight);
        context.append("g").attr("class", "axis x-axis-mini").attr("transform", `translate(0,${brushHeight})`).call(d3.axisBottom(x2).ticks(5).tickFormat(""));
        brush = d3.brushX().extent([[0, 0], [width, brushHeight]]).on("brush end", brushed);
        brushGroup = context.append("g").attr("class", "brush").call(brush);
        
        updateChart("oda", true);
    });

    function updateChart(flowType, init=false) {
        currentFlow = flowType;
        const color = flowColors[flowType];
        const data = preCalcData[flowType];

        x.domain([0, d3.max(data, d => d.value)||0]);
        y.domain(data.map(d => d.sector));
        x2.domain(x.domain());

        const t = d3.transition().duration(500);
        xAxisGroup.transition(t).call(d3.axisBottom(x).ticks(5).tickFormat(d => "$" + d3.format(".2s")(d).replace("G", "B")));
        
        // --- TEXT TRUNCATION LOGIC ---
        yAxisGroup.transition(t).call(d3.axisLeft(y).tickFormat(d => {
            // If text is longer than 25 chars, cut it and add "..."
            return d.length > 25 ? d.substring(0, 25) + "..." : d;
        }));

        gridGroup.transition(t).call(d3.axisBottom(x).ticks(5).tickSize(height).tickFormat(""));

        const bars = barGroup.selectAll(".bar").data(data, d => d.sector);
        bars.exit().transition().duration(250).attr("width", 0).remove();
        
        bars.transition().duration(500)
            .attr("y", d=>y(d.sector)).attr("height", y.bandwidth())
            .attr("width", d=>x(d.value)).style("fill", color);

        const newBars = bars.enter().append("rect").attr("class", "bar")
            .attr("y", d=>y(d.sector)).attr("height", y.bandwidth()).attr("x", 0).attr("width", 0).style("fill", color)
            .on("click", function(e, d) {
                d3.selectAll(".bar").interrupt().style("fill", flowColors[currentFlow]);
                d3.select(this).style("fill", "#2563eb");
            })
            .on("mouseover", (e, d) => {
                d3.select("#tooltip").style("opacity", 1).html(`<strong>${d.sector}</strong><br>$${d.value.toLocaleString()}`)
                    .style("left", (e.pageX+10)+"px").style("top", (e.pageY-20)+"px");
            })
            .on("mouseout", () => d3.select("#tooltip").style("opacity", 0));

        if(init) {
            newBars.transition().duration(800).delay((d,i)=>i*10).attr("width", d=>x(d.value));
            setTimeout(() => { if(brushGroup) brushGroup.call(brush.move, x.range()); }, 1000);
        } else {
            newBars.transition().duration(500).attr("width", d=>x(d.value));
            if(brushGroup) brushGroup.call(brush.move, x.range());
        }
    }

    function brushed(event) {
        if(!event.selection) { x.domain(x2.domain()); }
        else { x.domain([x2.invert(event.selection[0]), x2.invert(event.selection[1])]); }
        xAxisGroup.call(d3.axisBottom(x).ticks(5).tickFormat(d => "$" + d3.format(".2s")(d).replace("G", "B")));
        gridGroup.call(d3.axisBottom(x).ticks(5).tickSize(height).tickFormat(""));
        barGroup.selectAll(".bar").attr("width", d => Math.max(0, x(d.value)));
    }

    window.setFlowType = (t) => updateChart(t);
    window.zoomIn = () => { if(brushGroup) brushGroup.call(brush.move, [0, width*0.8]); };
    window.zoomOut = () => { if(brushGroup) brushGroup.call(brush.move, x2.range()); };
    window.resetZoom = () => { 
        d3.selectAll(".bar").style("fill", flowColors[currentFlow]); 
        if(brushGroup) brushGroup.call(brush.move, x2.range()); 
    };
</script>
</body>
</html>